// Console
#include <windows.h>
#include <stdio.h>

#include "WolfDef.h"

#define LINE_WIDTH 40
#define SCRMSGS		1
#define CON_LINES	300
#define INP_HIST	64
#define INPUT_LEN 256

typedef struct 
{
	unsigned char text[LINE_WIDTH+1];
	int timeout; // in milliseconds
	unsigned char flags;
} scrMsg;
typedef struct
{
	unsigned char text[INPUT_LEN+1];
	int curpos;
	int rscroll;
	int len;
} inpStr;
struct Console_
{
	int Pos;	 // (0-Closed, 480-FullScreen, 0..480-Coresponding!)
	int State; // (0-Closed, 1-Opening, -1-Closing, 2-Opened)
} Console;

scrMsg ScrMsg[SCRMSGS];
unsigned char	ConMsg[CON_LINES][LINE_WIDTH+1];
inpStr ConsoleInput[INP_HIST];
unsigned char history_input=0, total_input=0;
int con_backscroll=0, con_totallines=0;
int con_x=0;
bool con_forcedup;	// (full screen console) because no entities to refresh
// ------------------------- * Devider * -------------------------

int Con_Init(void)
{
	FILE *fp;

	memset(ScrMsg, 0, sizeof(ScrMsg));
	memset(ConMsg, 0, sizeof(ConMsg));
	memset(&Console, 0, sizeof(Console));
	memset(ConsoleInput, 0, sizeof(ConsoleInput));

	fp=fopen(BASEDIR"condump.txt", "wt");
	fprintf(fp, "This file was generated by WolfGL-3D version %s\n\n", VERSION);
	fclose(fp);

	Cmd_AddCommand("toggleconsole", Con_ToggleConsole_f);
	Cmd_AddCommand("clear", Con_Clear_f);
	Con_Printf("Console initialized.\n");
	return 1;
}

void Con_LineFeed(void)
{
	memmove(ConMsg[1], ConMsg[0], sizeof(ConMsg)-sizeof(ConMsg[0]));
	if(++con_totallines>=CON_LINES) con_totallines=CON_LINES;
}

void Con_MsgLFeed(void)
{
	memmove(&ScrMsg[1], &ScrMsg[0], sizeof(ScrMsg)-sizeof(ScrMsg[0]));
}

void Con_AddMsg(char *text)
{
	char *msg=ScrMsg[0].text;
	
	Con_MsgLFeed();

	ScrMsg[0].timeout=255;
	ScrMsg[0].flags=0;

	while(*text)
	{
		if(*text=='\n' || (msg-ScrMsg[0].text)>=LINE_WIDTH)
		{
			*msg='\0';
			Con_MsgLFeed();
			ScrMsg[0].timeout=255;
			ScrMsg[0].flags=0;
			msg=ScrMsg[0].text;
			if(*text=='\n') text++;
			continue;
		}
		*msg=*text;
		msg++;
		text++;
	}
	*msg='\0';
}

void Con_AddText(char *text)
{
	int		c, l;
	static int	cr;
	unsigned char mask;
	
	con_backscroll = 0;

	if(text[0]==1)
	{
		mask=128;		// go to colored text
		text++;
	}
	else if(text[0]==2)
	{
		mask=128;		// go to colored text
		text++;
	}
	else
		mask=0;

	while( (c=*text) )
	{
		if(*text<=' ') //wrap only whole words!
		{
			// count word length
			for(l=1; l<LINE_WIDTH; l++)
				if(text[l]<=' ')	break;

			// word wrap
			if(l!=LINE_WIDTH && (con_x+l > LINE_WIDTH) )
			{
				ConMsg[0][con_x]='\0';
				text++;
				c=*text;
				con_x=0;
			}
		}

		text++;
		
		if(!con_x)
		{
			if(!cr)	Con_LineFeed();
			else cr=0;
		}

		switch(c)
		{
		case '\n':
			ConMsg[0][con_x]='\0';
			con_x=0;
			break;
		case '\r':
			ConMsg[0][con_x]='\0';
			con_x=0;
			cr=1;
			break;
		case '\b':
			if(con_x>0)	con_x--;
			break;
		default:	// display character and advance
			ConMsg[0][con_x]=c|mask;
			con_x++;
			if(con_x>=LINE_WIDTH)
			{
				if(!text[1]) break; // do not wrap if end of line!
				ConMsg[0][LINE_WIDTH]='\0';
				con_x=0;
			}
			break;
		}
	}
	if(con_x) ConMsg[0][con_x]='\0';
}

void Con_DebugLog(char *text)
{
	FILE *fp;

	fp=fopen(BASEDIR"condump.txt", "at");
	fprintf(fp, "%s", text);
	fclose(fp);
}

void Con_Printf(char *fmt, ...)
{
	va_list	argptr;
	char msg[1024];
		
	va_start(argptr,fmt);
	vsprintf(msg, fmt, argptr);
	va_end(argptr);

	Con_AddText(msg);
	Con_DebugLog(msg);
}

void Msg_Printf(char *fmt, ...)
{
	va_list	argptr;
	char msg[1024];
		
	va_start(argptr,fmt);
	vsprintf(msg, fmt, argptr);
	va_end(argptr);

	Con_AddMsg(msg);
	Con_AddText(msg);
	Con_AddText("\n");
	Con_DebugLog(msg);
	Con_DebugLog("\n");
}

void Con_ClearScrMsg(void)
{
	int	n;
	
	for(n=0; n<SCRMSGS; n++)
		ScrMsg[n].timeout = 0;
}

void Con_ProcMsg(void)
{
	int n;

	for(n=0; n<SCRMSGS; n++)
		if(--ScrMsg[n].timeout < 0)
			ScrMsg[n].timeout = 0;
}

void Con_Process(void)
{
	Con_ProcMsg();
	
	switch(Console.State)
	{
	case 0:
		break;
	case 1:
		Console.Pos+=10;
		if(Console.Pos>=280){Console.Pos=280; Console.State=2;}
		break;
	case -1:
		Console.Pos-=10;
		if(Console.Pos<=0){Console.Pos=0;	Console.State=0;}
		break;
	default:
		break;
	}
}

// ------------------------- * Devider * -------------------------
void Con_DrawConsole(void)
{
	int conlen, offset;
	unsigned char alpha;
	int n;

	FNT_SetFont(FNT_CONSOLE); // fixed width font!
	FNT_SetScale(1, 1);
	FNT_SetStyle(0, 0, 0);

	Con_DrawMessages();

	if(Console.State==0) return; // no console visible!
	alpha=(Console.Pos<255) ? (unsigned char)Console.Pos : 0xFF;
	FNT_SetColor(0xFF, 0xFF, 0xFF, alpha);
	FNT_SetColorSh(0x00, 0x00, 0x00, alpha);
	FNT_SetStyle(0, 1, 0);

	Vid_DrawConBack(Console.Pos, alpha);

	conlen=(Console.Pos>>4)-1;  // number of lines to draw
	if(conlen<0) conlen=0;
	offset=Console.Pos&0x0F; // same as: %16;

	offset-=6; // leave space in bottom of console!

	for(n=1; n<conlen; n++)
	{
		FNT_PrintPosOff(0, conlen-n-1, 0, offset, ConMsg[n+con_backscroll]);
	}
	if(con_backscroll)
	{
		FNT_SetColor(0xFF, 0xFF, 0x00, 0xFF);
		FNT_PrintPosOff(0, conlen-1, 0, offset, " ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^");
		FNT_SetColor(0xFF, 0xFF, 0xFF, 0xFF);
	}
	else
		FNT_PrintPosOff(0, conlen-1, 0, offset, ConMsg[0]);

	if(Console.State>=1)
	{
		FNT_PrintfPosOff(0, conlen, 0, offset, "]%s", &ConsoleInput[0].text[ConsoleInput[0].rscroll]);
		FNT_SetColor(0xFF, 0x00, 0xFF, 0xFF);
		FNT_PrintPosOff(ConsoleInput[0].curpos-ConsoleInput[0].rscroll+1, conlen, 0, offset, "_");
	}
}

void Con_DrawMessages(void)
{
	int i, line=0;

	for(i=SCRMSGS; i>=0; i--)
	{
		if(!ScrMsg[i].timeout) continue;
		FNT_SetColor(0xFF, 0x00, 0x00, (unsigned char)(ScrMsg[i].timeout>127 ? 255 : ScrMsg[i].timeout<<1) );

		FNT_PrintPos(0, line, ScrMsg[i].text);
		line++;
	}
}

// ------------------------- * Devider * -------------------------
void Con_ClearInput(void)
{
	memset(&ConsoleInput[0], 0, sizeof(ConsoleInput[0]));
	ConsoleInput[0].len=ConsoleInput[0].curpos=ConsoleInput[0].rscroll=0;
	ConsoleInput[0].text[0]=0;
}

void Con_Clear_f(void)
{
	memset(ConMsg, 0, sizeof(ConMsg));
	con_backscroll=con_totallines=0;
}

void Con_ToggleConsole_f(void)
{
	switch(Console.State)
	{
	case 0:
		Console.State=1;
		key_dest=key_console;
		break;
	case 2:
		Con_ClearInput();
	case 1:
		Console.State=-1;
		key_dest=key_game;
		break;
	case -1:
		Console.State=1;
		key_dest=key_console;
		break;
	}
}

// ------------------------- * Devider * -------------------------
void Con_KeyInput(int key)
{
	char *cmd;

	if(Console.State<1) return; // console not interested in input!

	switch(key)
	{
	case K_ENTER: // Return (Enter)
		if(!ConsoleInput[0].len)
		{
			Con_Printf("]\n");
			history_input=0;
			Con_ClearInput(); // just in case!
			return;
		}
		Con_Printf("]%s\n", ConsoleInput[0].text);
		memmove(&ConsoleInput[1], &ConsoleInput[0], sizeof(ConsoleInput)-sizeof(ConsoleInput[0]));
		if(++total_input>=INP_HIST) total_input=INP_HIST-1;
		history_input=0;
		Cbuf_AddText(ConsoleInput[0].text);
		Cbuf_AddText("\n");
		Con_ClearInput();
		return;
	case K_TAB: // Tab
		cmd=Cmd_CompleteCommand(ConsoleInput[0].text);
		if(!cmd)
			cmd=Cvar_CompleteVariable(ConsoleInput[0].text);
		if(cmd)
		{
			strcpy(ConsoleInput[0].text, cmd);
			ConsoleInput[0].len=strlen(cmd)+1;
			ConsoleInput[0].curpos=ConsoleInput[0].len;
			ConsoleInput[0].text[ConsoleInput[0].len-1]=' ';
		}
		return;
	case K_BACKSPACE: // BackSpace
		if(ConsoleInput[0].curpos==0) return;
		memmove(&ConsoleInput[0].text[ConsoleInput[0].curpos-1], 
						&ConsoleInput[0].text[ConsoleInput[0].curpos], 
						sizeof(ConsoleInput[0].text)-ConsoleInput[0].curpos);
		ConsoleInput[0].curpos--;
		ConsoleInput[0].len--;
		if(ConsoleInput[0].curpos<=ConsoleInput[0].rscroll)
		{
			ConsoleInput[0].rscroll-=20;
			if(ConsoleInput[0].rscroll<0) ConsoleInput[0].rscroll=0;
		}
		return;
	case K_DEL: // Del
		if(ConsoleInput[0].curpos==ConsoleInput[0].len) return;
		memmove(&ConsoleInput[0].text[ConsoleInput[0].curpos], 
						&ConsoleInput[0].text[ConsoleInput[0].curpos+1], 
						sizeof(ConsoleInput[0].text)-ConsoleInput[0].curpos-1);
		ConsoleInput[0].len--;
		return;
	case K_RIGHTARROW:
		if(ConsoleInput[0].curpos<ConsoleInput[0].len)
		ConsoleInput[0].curpos++;
		if(ConsoleInput[0].curpos-ConsoleInput[0].rscroll >= LINE_WIDTH-1)
			ConsoleInput[0].rscroll++;
		return;
	case K_LEFTARROW:
		if(ConsoleInput[0].curpos==0) return;
		ConsoleInput[0].curpos--;
		if(ConsoleInput[0].curpos<=ConsoleInput[0].rscroll)
		{
			ConsoleInput[0].rscroll-=20;
			if(ConsoleInput[0].rscroll<0) ConsoleInput[0].rscroll=0;
		}
		return;
	case K_UPARROW:
		if(history_input>=total_input) return;
		ConsoleInput[0]=ConsoleInput[++history_input];
		return;
	case K_DOWNARROW:
		if(history_input==1)
		{
			history_input=0;
			ConsoleInput[0].text[0]=0;
			ConsoleInput[0].curpos=0;
			ConsoleInput[0].len=0;
			ConsoleInput[0].rscroll=0;
			return;
		}
		if(history_input<1) return;
		ConsoleInput[0]=ConsoleInput[--history_input];
		return;
	case K_PGUP: // PgUp
		con_backscroll+=2;
		if(con_backscroll>con_totallines-1)	con_backscroll=con_totallines-1;
		return;
	case K_PGDN: // PgDn
		con_backscroll-=2;
		if(con_backscroll<0) con_backscroll=0;
		return;
	case K_HOME: // Home
		con_backscroll=con_totallines-1;
		return;
	case K_END: // End
		con_backscroll=0;
		return;
	}
	if(key<32 || key>127)	return;	// non printable FIXME: add russian!!!!

	if(ConsoleInput[0].curpos>=INPUT_LEN) return;
	memmove(&ConsoleInput[0].text[ConsoleInput[0].curpos+1],
					&ConsoleInput[0].text[ConsoleInput[0].curpos],
					sizeof(ConsoleInput[0].text)-ConsoleInput[0].curpos-1 );
	ConsoleInput[0].text[ConsoleInput[0].curpos]=key;
	ConsoleInput[0].len++;
	ConsoleInput[0].curpos++;
	if(ConsoleInput[0].curpos-ConsoleInput[0].rscroll >= LINE_WIDTH-1) ConsoleInput[0].rscroll++;
	ConsoleInput[0].text[INPUT_LEN]='\0'; // little fix!
	if(ConsoleInput[0].len>INPUT_LEN) ConsoleInput[0].len=INPUT_LEN;
}